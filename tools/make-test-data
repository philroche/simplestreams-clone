#!/usr/bin/python
#   Copyright (C) 2013 Canonical Ltd.
#
#   Author: Scott Moser <scott.moser@canonical.com>
#
#   Simplestreams is free software: you can redistribute it and/or modify it
#   under the terms of the GNU Affero General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   Simplestreams is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
#   License for more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with Simplestreams.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import hashlib
import errno
import json
import os
import os.path
import sys
from simplestreams import util
from simplestreams import contentsource as cs

try:
    # this is just python2 or python3 compatible prepping for get_url_len
    import urllib.request
    url_request = urllib.request.Request
    url_open = urllib.request.urlopen
except ImportError as e:
    import urllib2
    url_request = urllib2.Request
    url_open = urllib2.urlopen

import toolutil

# could support reading from other mirrors
# for example:
#   http://cloud-images-archive.ubuntu.com/
#   file:///srv/ec2-images
#
BASE_URLS = (
  "http://cloud-images.ubuntu.com/",
)

FAKE_DATA = {
    'root.tar.gz': {
        'size': 10240, 'md5': '1276481102f218c981e0324180bafd9f',
        'sha256': '84ff92691f909a05b224e1c56abb4864f01b4f8e3c854e4bb4c7baf1d3f6d652'},
    'tar.gz': {
        'size': 11264, 'md5': '820a81e0916bac82838fd7e74ab29b15',
        'sha256': '5309e677c79cffae49a65728c61b436d3cdc2a2bab4c81bf0038415f74a56880'},
    'disk1.img': {
        'size': 12288, 'md5': '4072783b8efb99a9e5817067d68f61c6',
        'sha256': 'f3cc103136423a57975750907ebc1d367e2985ac6338976d4d5a439f50323f4a'},
    'uefi1.img': {
        'size': 12421, 'md5': 'd41d8cd98f00b204e9800998ecf8427e',
        'sha256': '8ca9c39f2200d299b011f5018c9d27a5a70f5a6b4c24f2fe06a94bc0e8c1213f'},
    'manifest': {
        'size': 10241, 'md5': 'd570918d26da051cf77f6544b79bbf15',
        'sha256': '232a9fa5dfa39c75f9c30a4a4292466515134ef734e926ffcae7de455ac5255d'},
    'ova': {
        'size': 12399, 'md5': '65b6348179a464fb0a6a1c2ed4d9aa19',
        'sha256': '102c1cba2e133efd81b597ef8ee30af629e4d7d77b9ca07ca2feb6e958ffaa67'}
}

EC2_ENDPOINTS = {
    'default': 'https://ec2.%s.amazonaws.com',
    'cn-north-1': 'https://ec2.cn-north-1.amazonaws.com.cn',
    'us-gov-west-1': 'https://ec2.us-gov-west-1.amazonaws.com'
}

UBUNTU_RDNS = "com.ubuntu.cloud"

REAL_DATA = os.environ.get("REAL_DATA", False)
if REAL_DATA and REAL_DATA != "0":
    REAL_DATA = True
else:
    REAL_DATA = False

FILE_DATA = {}


def get_cache_data(path, field):
    dirname = os.path.dirname(path)
    bname = os.path.basename(path)
    return FILE_DATA.get(dirname, {}).get(bname, {}).get(field)


def store_cache_data(path, field, value):
    dirname = os.path.dirname(path)
    bname = os.path.basename(path)
    if dirname not in FILE_DATA:
        FILE_DATA[dirname] = {}
    if bname not in FILE_DATA[dirname]:
        FILE_DATA[dirname][bname] = {}
    FILE_DATA[dirname][bname][field] = value

def store_cache_entry(path, data):
    for k, v in data.items():
        store_cache_data(path, k, v)


def save_cache():
    if FILE_DATA:
        hashcache = FILE_DATA['filename']
        with open(hashcache, "w") as hfp:
            hfp.write(json.dumps(FILE_DATA, indent=1))


def get_checksums_from_url(path, hashes=None):
    if hashes is None:
        hashes = ["sha256", "md5"]

    content = load_url(path).decode("utf-8")

    ret = {}
    for hashname in ("md5", "sha256"):
        t = hashlib.new(hashname)
        t.update(content)
        ret[hashname] = t.hexdigest()
    return ret


def load_sums_from_sumfiles(path):
    for cksum in ("md5", "sha256"):
        content = None
        if get_cache_data(path + "/" + cksum.upper(), 'size'):
            continue

        sfile_url = path + "/%sSUMS" % cksum.upper()
        content = load_url(sfile_url).decode("utf-8")

        for line in content.splitlines():
            (hexsum, fname) = line.split()
            if fname.startswith("*"):
                fname = fname[1:]
            store_cache_data(path + "/" + fname, cksum, hexsum)

        store_cache_data(path + "/" + cksum.upper(), "size", len(content))


def load_url(path):
    url = BASE_URLS[0] + path
    mirrors = [u + path for u in BASE_URLS[1:]]
    data = cs.UrlContentSource(url, mirrors=mirrors).read()
    sys.stderr.write("read url %s\n" % path)
    return data


def load_data_in_dir(path):
    qfile = ".qindex.json"
    try:
        content = load_url(path + "/" + qfile).decode("utf-8")
        for fpath, data in json.loads(content).items():
            store_cache_entry(path + "/" + fpath, data)
        return
    except IOError as e:
        if e.errno != errno.ENOENT:
            raise
        sys.stderr.write("no '%s' in %s\n" % (qfile, path))

    load_sums_from_sumfiles(path)


def get_cloud_images_file_hash(path):
    md5 = get_cache_data(path, 'md5')
    sha256 = get_cache_data(path, 'sha256')
    if md5 and sha256:
        return {'md5': md5, 'sha256': sha256}

    dirname = os.path.dirname(path)

    load_data_in_dir(dirname)

    ret = {'md5': get_cache_data(path, 'md5'),
           'sha256': get_cache_data(path, 'sha256')}

    # if we were missing an md5 or a sha256 for the manifest
    # file, then get them ourselves.
    if path.endswith(".manifest") and None in ret.values():
        sys.stderr.write("getting manifest url %s\n" % path)
        ret = get_checksums_from_url(path)
        for cksum in ret:
            store_cache_data(dirname + "/" + os.path.basename(path),
                             cksum, ret[cksum])

    missing = [h for h in ret if not ret[h]]
    if missing:
        raise Exception("Unable to get checksums (%s) for %s" %
                        (missing, path))

    save_cache()
    return ret


def get_url_len(url):
    if url.startswith("file:///"):
        path = url[len("file://"):]
        return os.stat(path).st_size
    if os.path.exists(url):
        return os.stat(url).st_size

    # http://stackoverflow.com/questions/4421170/python-head-request-with-urllib2
    sys.stderr.write("getting size for %s\n" % url)
    request = url_request(url)
    request.get_method = lambda : 'HEAD'
    response = url_open(request)
    return int(response.headers.get('content-length', 0))


def get_cloud_images_file_size(path):
    size = get_cache_data(path, 'size')
    if size:
        return size

    for burl in BASE_URLS:
        try:
            size = int(get_url_len(burl + path))
            break
        except Exception as error:
            pass

    if not size:
        raise error
    store_cache_data(path, 'size', size)
    save_cache()
    return size


def create_fake_file(prefix, item):
    fpath = os.path.join(prefix, item['path'])
    path = item['path']

    data = FAKE_DATA[item['ftype']]

    util.mkdir_p(os.path.dirname(fpath))
    print("creating %s" % fpath)
    with open(fpath, "w") as fp:
        fp.truncate(data['size'])

    item.update(data)

    for cksum in util.CHECKSUMS:
        if cksum in item and not cksum in data:
            del item[data]

    return


def dl_load_query(path):
    tree = {}
    for rline in toolutil.load_query_download(path):
        (stream, rel, build, label, serial, arch, filepath, fname) = rline

        if stream not in tree:
            tree[stream] = {'products': {}}
        products = tree[stream]['products']

        version = toolutil.REL2VER[rel]['version']

        prodname_rdns = UBUNTU_RDNS
        if stream != "released":
            prodname_rdns += "." + stream

        prodname = ':'.join([prodname_rdns, build, version, arch])

        if prodname not in products:
            products[prodname] = {
                "release": rel,
                "version": version,
                "arch": arch,
                "versions": {}
            }

        product = products[prodname]

        if serial not in product['versions']:
            product['versions'][serial] = {'items': {}, "label": label}

        name = pubname(label, rel, arch, serial, build)
        product['versions'][serial]['pubname'] = name

        items = product['versions'][serial]['items']

        # ftype: finding the unique extension is not-trivial
        # take basename of the filename, and remove up to "-<arch>?"
        # so ubuntu-12.04-server-cloudimg-armhf.tar.gz becomes
        # 'tar.gz' and 'ubuntu-12.04-server-cloudimg-armhf-disk1.img'
        # becomse 'disk1.img'
        dash_arch = "-" + arch
        ftype = filepath[filepath.rindex(dash_arch) + len(dash_arch) + 1:]
        items[ftype] = {
            'path': filepath,
            'ftype': ftype
        }

    return tree


def pubname(label, rel, arch, serial, build='server'):
    version = toolutil.REL2VER[rel]['version']

    if label == "daily":
        rv_label = rel + "-daily"
    elif label == "release":
        rv_label = "%s-%s" % (rel, version)
    elif label.startswith("beta"):
        rv_label = "%s-%s-%s" % (rel, version, label)
    else:
        rv_label = "%s-%s" % (rel, label)
    return "ubuntu-%s-%s-%s-%s" % (rv_label, arch, build, serial)


def ec2_load_query(path):
    tree = {}

    dmap = {
        "north": "nn",
        "northeast": "ne",
        "east": "ee",
        "southeast": "se",
        "south": "ss",
        "southwest": "sw",
        "west": "ww",
        "northwest": "nw",
        "central": "cc",
    }
    itmap = {
        'pv': {'instance': "pi", "ebs": "pe", "ssd": "es", "io1": "eo"},
        'hvm': {'instance': "hi", "ebs": "he", "ssd": "hs", "io1": "ho"}
    }

    for rline in toolutil.load_query_ec2(path):
        (stream, rel, build, label, serial, store, arch, region,
         iid, _kern, _rmd, vtype) = rline

        if stream not in tree:
            tree[stream] = {'products': {}}
        products = tree[stream]['products']

        version = toolutil.REL2VER[rel]['version']

        prodname_rdns = UBUNTU_RDNS
        if stream != "released":
            prodname_rdns += "." + stream

        prodname = ':'.join([prodname_rdns, build, version, arch])

        if prodname not in products:
            products[prodname] = {
                "release": rel,
                "version": version,
                "arch": arch,
                "versions": {}
            }

        product = products[prodname]

        if serial not in product['versions']:
            product['versions'][serial] = {'items': {}, "label": label}
        items = product['versions'][serial]['items']

        name = pubname(label, rel, arch, serial, build)
        product['versions'][serial]['pubname'] = name

        if store == "instance-store":
            store = 'instance'
        elif '-' in store:
            store = store.split('-')[-1]
        if vtype == "paravirtual":
            vtype = "pv"

        # create the item key:
        #  - 2 letter country code (us) . 3 for govcloud (gww)
        #  - 2 letter direction (nn=north, nw=northwest, cc=central)
        #  - 1 digit number
        #  - 1 char for virt type
        #  - 1 char for root-store type

        # Handle special case of 'gov' regions
        _region = region
        pre_cc = ""
        if '-gov-' in region:
            _region = region.replace('gov-', '')
            pre_cc = "g"

        (cc, direction, num) = _region.split("-")

        ikey = pre_cc + cc + dmap[direction] + num + itmap[vtype][store]

        items[ikey] = {
            'id': iid,
            'root_store': store,
            'virt': vtype,
            'crsn': region,
        }
    return tree


def printitem(item, exdata):
    full = exdata.copy()
    full.update(item)
    print(full)


def create_image_data(query_tree, out_d, streamdir):
    license = 'http://www.canonical.com/intellectual-property-policy'
    hashcache = os.path.join(query_tree, "FILE_DATA_CACHE")
    FILE_DATA['filename'] = hashcache
    if os.path.isfile(hashcache):
        FILE_DATA.update(json.loads(open(hashcache, "r").read()))

    ts = util.timestamp()
    tree = dl_load_query(query_tree)

    def update_hashes(item, tree, pedigree):
        item.update(get_cloud_images_file_hash(item['path']))

    def update_sizes(item, tree, pedigree):
        item.update({'size': get_cloud_images_file_size(item['path'])})

    cid_fmt = "com.ubuntu.cloud:%s:download"
    for stream in tree:
        def create_file(item, tree, pedigree):
            create_fake_file(os.path.join(out_d, stream), item)

        cid = cid_fmt % stream
        if REAL_DATA:
            util.walk_products(tree[stream], cb_item=update_hashes)
            util.walk_products(tree[stream], cb_item=update_sizes)
        else:
            util.walk_products(tree[stream], cb_item=create_file)

        tree[stream]['format'] = "products:1.0"
        tree[stream]['updated'] = ts
        tree[stream]['content_id'] = cid
        tree[stream]['datatype'] = 'image-downloads'
        tree[stream]['license'] = license

        outfile = os.path.join(out_d, stream, streamdir, cid + ".json")
        util.mkdir_p(os.path.dirname(outfile))
        with open(outfile, "w") as fp:
            sys.stderr.write("writing %s\n" % outfile)
            fp.write(json.dumps(tree[stream], indent=1) + "\n")

    # save hashes data
    save_cache()
    return tree


def create_aws_data(query_tree, out_d, streamdir):
    tree = ec2_load_query(query_tree)
    ts = util.timestamp()
    cid_fmt = "com.ubuntu.cloud:%s:aws"
    for stream in tree:
        cid = cid_fmt % stream
        # now add the '_alias' data
        regions = set()

        def findregions(item, tree, pedigree):
            regions.add(item['crsn'])

        util.walk_products(tree[stream], cb_item=findregions)

        tree[stream]['_aliases'] = {'crsn': {}}
        for region in regions:
            epoint = EC2_ENDPOINTS['default'] % region
            if region in EC2_ENDPOINTS:
                epoint = EC2_ENDPOINTS[region]

            tree[stream]['_aliases']['crsn'][region] = {
                'endpoint': epoint,
                'region': region}

        tree[stream]['format'] = "products:1.0"
        tree[stream]['datatype'] = "image-ids"
        tree[stream]['updated'] = ts
        tree[stream]['content_id'] = cid
        outfile = os.path.join(out_d, stream, streamdir, cid + ".json")
        util.mkdir_p(os.path.dirname(outfile))
        with open(outfile, "w") as fp:
            sys.stderr.write("writing %s\n" % outfile)
            fp.write(json.dumps(tree[stream], indent=1) + "\n")

    return tree


def main():
    parser = argparse.ArgumentParser(description="create example content tree")

    parser.add_argument("query_tree", metavar='query_tree',
                        help=('read in content from /query tree. Hint: ' +
                              'make exdata-query'))

    parser.add_argument("out_d", metavar='out_d',
                        help=('create content under output_dir'))

    parser.add_argument('--sign', action='store_true', default=False,
                        help='sign all generated files')

    args = parser.parse_args()
    streamdir = "streams/v1"

    dltree = create_image_data(args.query_tree, args.out_d, streamdir)

    aws_tree = create_aws_data(args.query_tree, args.out_d, streamdir)

    for streamname in aws_tree:
        index = {"index": {}, 'format': 'index:1.0',
                 'updated': util.timestamp()}

        clouds = list(aws_tree[streamname]['_aliases']['crsn'].values())
        index['index'][aws_tree[streamname]['content_id']] = {
            'updated': aws_tree[streamname]['updated'],
            'datatype': aws_tree[streamname]['datatype'],
            'clouds': clouds,
            'cloudname': "aws",
            'path': '/'.join((streamdir,
                             "%s.json" % aws_tree[streamname]['content_id'],)),
            'products': list(aws_tree[streamname]['products'].keys()),
            'format': aws_tree[streamname]['format'],
        }
        index['index'][dltree[streamname]['content_id']] = {
            'updated': dltree[streamname]['updated'],
            'datatype': dltree[streamname]['datatype'],
            'path': '/'.join((streamdir,
                             "%s.json" % dltree[streamname]['content_id'],)),
            'products': list(dltree[streamname]['products'].keys()),
            'format': dltree[streamname]['format']
        }

        outfile = os.path.join(args.out_d, streamname, streamdir, 'index.json')
        util.mkdir_p(os.path.dirname(outfile))
        with open(outfile, "w") as fp:
            sys.stderr.write("writing %s\n" % outfile)
            fp.write(json.dumps(index, indent=1) + "\n")

    if args.sign:
        def printstatus(name):
            sys.stderr.write("signing %s\n" % name)
        for root, dirs, files in os.walk(args.out_d):
            for f in [f for f in files if f.endswith(".json")]:
                toolutil.signjson_file(os.path.join(root, f),
                                     status_cb=printstatus)

    return

if __name__ == '__main__':
    sys.exit(main())

# vi: ts=4 expandtab
